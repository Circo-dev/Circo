var documenterSearchIndex = {"docs":
[{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Requirements","page":"Installation","title":"Requirements","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Linux or OSX \nJulia >= v\"1.4\" download\ngit (Tested with \"version 2.17.1\") download\nNode.js (Tested with \"v12.4.0\") download - For the optional frontend","category":"page"},{"location":"install/#Install-and-run-a-sample","page":"Installation","title":"Install & run a sample","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"You need to checkout two repos: The Circo \"backend\" and the CircoCore.js \"frontend\".","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"In terminal #1 (backend)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"git clone https://github.com/Circo-dev/Circo.git\ncd Circo/\njulia --project -e 'using Pkg;Pkg.instantiate()'\nbin/circonode.sh --threads 6 --zygote","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This starts a local (in-process) cluster with six schedulers running the sample project.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"In terminal #2 (monitoring frontend, optional)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"git clone https://github.com/Circo-dev/CircoCore.js.git\ncd CircoCore.js\nnpm install\nnpm run serve","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This starts a web server on port 8000. Open http://localhost:8000","category":"page"},{"location":"whitepaper/0_abstract/#Machine-intelligence-shapes-our-future.-Let's-shape-it-in-our-own-image!","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"","category":"section"},{"location":"whitepaper/0_abstract/#Circo-1.0-whitepaper","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Circo 1.0 whitepaper","text":"","category":"section"},{"location":"whitepaper/0_abstract/","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"Draft","category":"page"},{"location":"whitepaper/0_abstract/","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"Krisztián Schäffer, ","category":"page"},{"location":"whitepaper/0_abstract/","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"Abstract.  Human-like artificial intelligence would allow machines to act more naturally, thus climb up from the uncanny walley[uw] on the right side.","category":"page"},{"location":"whitepaper/0_abstract/","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"(Image: Uncanny Walley)","category":"page"},{"location":"whitepaper/0_abstract/","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"The rise of deep learning initiated an era where human-level intelligence seems to be within sight. But the perceptron model, although itself biologically inspired, is only a parody of the human brain. Building on it alone would lead to zombies[z] at best. ","category":"page"},{"location":"whitepaper/0_abstract/","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"We propose a solution based on structural similarity, focusing on physical compatibility in the low-level runtime and gradually refining a biologically inspired model on top of it.","category":"page"},{"location":"whitepaper/0_abstract/","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"Intelligence emerges from the collective behavior of independent actors embedded in spacetime, communicating by asynchronous message passing, while exchanging information and energy. Simulated spacetime is mapped to computing hardware dynamically for optimal execution. Actors maintain their identity and reputation, used by a decentralized judicial system to enforce rules statistically.","category":"page"},{"location":"whitepaper/0_abstract/","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"[uw] \"Uncanny valley is a hypothesized relationship between the degree of an object's resemblance to a human being and the emotional response to such an object.\" Wikipedia.","category":"page"},{"location":"whitepaper/0_abstract/","page":"Machine intelligence shapes our future. Let's shape it in our own image!","title":"Machine intelligence shapes our future. Let's shape it in our own image!","text":"[z] A philosophical zombie is indistinguishable from a normal person but does not have conscious experience. Wikipedia.","category":"page"},{"location":"plugindev/#Plugin-development","page":"Plugin development","title":"Plugin development","text":"","category":"section"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"To get familiar with the plugin system, please read the documentation of Plugins.jl","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"For sample code, look for any plugin in the source code. E.g. OnMessage is trivial, MsgStats and Event are a bit more involved.","category":"page"},{"location":"plugindev/#Plugin-Lifecycle","page":"Plugin development","title":"Plugin Lifecycle","text":"","category":"section"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"Following is the list of hooks to implement in plugins. Time goes top → down, except:","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"When there is no empty line between hooks, then the call order is not defined.\nIndented blocks may be called repeatedly","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"customfield(plugin, parent_type) # Provide extra fields to core types\n\nprepare(plugin, ctx) # Initial stage, plugins can use eval() here\n\n# Execution flow will reach top-level to allow staged code to run\n\nsetup!(plugin, scheduler) # Allocate resources\n\n    schedule_start(plugin, scheduler) # Scheduling may be stopped and restarted several times\n\n        schedule_continue(plugin, scheduler) # Scheduling continues after stop or pause (also called after start)\n\n            localdelivery() # Deliver a message to an actor (e.g. call onmessage)\n            actor_spawning() # Called when the new actor is already spawned, but before onspawn.\n            localroutes() # Handle messages that are targeted to actors not (currently) scheduled locally (e.g. during migration).\n            specialmsg() # Handle messages that are targeted to the scheduler (to the box 0)\n            remoteroutes() # Deliver messages to external targets\n            actor_activity_sparse16() # An actor just received a message, called with 1/16 probability\n            actor_activity_sparse256() # An actor just received a message, called with 1/256 probability\n            spawnpos() # Provide initial position of an actor when it is spawned\n\n            letin_remote() # Let external sources push messages into the queue (using deliver!).\n\n        schedule_pause(plugin, scheduler) # Scheduling is paused for a short time, e.g. to optimize code\n\n        stage(plugin, scheduler, stagenum) # Next stage TODO not implemented\n\n    schedule_stop(plugin, scheduler) # Scheduling is stopped for a potentially longer period\n\nshutdown!(plugin, scheduler) # Release resources","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"If you need a new hook, please file an issue to discuss your use case and find the best way to implement it!","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"TODO: A real plugin dev guide","category":"page"},{"location":"showcase/#Showcase","page":"Showcase","title":"Showcase","text":"","category":"section"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"When you install & run the system, on http://localhost:8000 soon you will see something like the following:","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"(Image: The sample loaded in Camera Diserta)","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"This is the tool \"Camera Diserta\" monitoring the default example: A linked list of 4000 actors, that - when started - will calculate the sum of the list repeatedly.","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"6 schedulers are available, but initially all the actors are scheduled on the same one. They will migrate to the other schedulers automatically. Actors are placed in a 3D space randomly - 3D isn't just a fancy visualization trick, but an important element of infoton optimization.","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"To try out the example, you have to send a \"Run\" message to the test coordinator:","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"Click \"coordinators\" in the upper left corner to filter only the test coordinator\nClick the coordinator to select it\nThe commands accepted by the coordinator will be queried from it\nClick \"Run\" when it appears\nClick \"all\" to see all the actors again\nWait for the magic to happen\nCheck the logs of the backend to see the speedup","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"After a while Camera Diserta will display something like the following:","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"(Image: Infoton-optimized version of the sample)","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"Large cuboids are the schedulers (size indicates the number of actors they execute), small cubes packed together are list item actors. Actors are scheduled on the scheduler that is closest in the 3D space.","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"As you can see, Circo's infoton optimization found out the structure of the list without using any \"domain\" knowledge, just by monitoring the communication of actors. It was also able to cut the list into 6 similarly sized segments (5 V-shaped and an I-shaped at the end of the list (bottom)). This solution minimizes the communication between schedulers.","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"The source code of the sample is at examples/linkedlist.jl.","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Circo is in alpha stage. Several stability issues are known. Please file an issue if you cannot find the workaround here!","category":"page"},{"location":"troubleshooting/#The-frontend-fails-to-display-the-correct-number-of-schedulers","page":"Troubleshooting","title":"The frontend fails to display the correct number of schedulers","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Open the JavaScript console (F12) and reload the page. You should see exactly one connection error message, and for every scheduler a log about \"actor registration\". If not, then you may need to restart your browser. It may also be possible that orphaned Circo schedulers are running.","category":"page"},{"location":"troubleshooting/#Sometimes-the-backend-crashes-when-the-browser-disconnects","page":"Troubleshooting","title":"Sometimes the backend crashes when the browser disconnects","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This seems like a bug in HTTP.jl or in Julia itself, partially workarounded, so happens rarely. Work on fixing this hasn't yet started, the only known workaround at the time is not closing the browser and not reloading the page while connected to the backend. Note that using the monitoring frontend is optional.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"info: Note\nItems from CircoCore are reexported thus available directly from Circo.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CircoCore]","category":"page"},{"location":"reference/#CircoCore.Actor","page":"Reference","title":"CircoCore.Actor","text":"abstract type Actor{TCoreState}\n\nSupertype of all actors.\n\nSubtypes must be mutable and must provide a field core::TCoreState that can remain undefined after creation.\n\nExamples\n\nmutable struct DataHolder{TValue, TCore} <: Actor{TCore}\n    value::TValue\n    core::TCore\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.ActorId","page":"Reference","title":"CircoCore.ActorId","text":"ActorId\n\nA cluster-unique id that is randomly generated when the actor is spawned (first scheduled).\n\nActorId is an alias to UInt64 at the time, so it may pop up in error messages as such.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.Addr","page":"Reference","title":"CircoCore.Addr","text":"Addr(postcode::PostCode, box::ActorId)\nAddr(readable_address::String)\nAddr()\n\nThe full address of an actor.\n\nWhen created without arguments, it will be the null address. See isnulladdr()\n\nIf the referenced actor migrates to a different scheduler, messages sent to the old address will bounce back as RecipientMoved and the Addr must be updated manually.\n\nExamples\n\nAddr(\"192.168.1.11:24721\", 0xbc6ac81fc7e4ea2)\n\nAddr(\"192.168.1.11:24721/bc6ac81fc7e4ea2\")\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.CircoContext","page":"Reference","title":"CircoCore.CircoContext","text":"CircoContext(;options...) <: AbstractContext\n\nStore configuration, manage staging and run-time code optimizations for Circo.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.Pos","page":"Reference","title":"CircoCore.Pos","text":"Pos(x::Real, y::Real, z::Real)\nPos(coords)\n\nA point in the 3D \"actor space\".\n\nYou can access the coords by pos.x, pos.y, pos.z.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.PostCode","page":"Reference","title":"CircoCore.PostCode","text":"PostCode\n\nA string that identifies a scheduler.\n\nExamples\n\n\"192.168.1.11:24721\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.addr-Tuple{Actor}","page":"Reference","title":"CircoCore.addr","text":"addr(a::Actor)\n\nReturn the address of the actor.\n\nCall this on a spawned actor to get its address. Throws UndefRefError if the actor is not spawned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.addr-Tuple{Any}","page":"Reference","title":"CircoCore.addr","text":"addr(entity)\n\nReturn the address of entity.\n\nThe default implementation returns the addr field, allowing you to use your own structs with such fields as message targets.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.become-Tuple{Circo Service, Actor, Actor}","page":"Reference","title":"CircoCore.become","text":"become(service, old::Actor, reincarnated::Actor)\n\nReincarnates the old actor into new, meaning that old will die, and reincarnated will be spawned reusing the address of old.\n\nNote: As the name suggests, become is the Circonian way of behavior change.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.box-Tuple{Actor}","page":"Reference","title":"CircoCore.box","text":"box(a::Actor)\n\nReturn the 'P.O. box' of the spawned actor.\n\nCall this on a spawned actor to get its id (aka box). Throws UndefRefError if the actor is not spawned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.box-Tuple{Any}","page":"Reference","title":"CircoCore.box","text":"box(a::Addr)::ActorId\n\nReturn the box of the address, that is the id of the actor.\n\nWhen the actor migrates, its box remains the same, only the PostCode of the address changes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.die-Tuple{Circo Service, Actor}","page":"Reference","title":"CircoCore.die","text":"die(service, me::Actor)\n\nUnschedule the actor from its current scheduler.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.getname-Tuple{Any, String}","page":"Reference","title":"CircoCore.getname","text":"function getname(service, name::String)::Union{Addr, Nothing}\n\nReturn the registered name from the scheduler-local registry, or nothing.\n\nSee also: NameQuery\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.isbaseaddress-Tuple{Addr}","page":"Reference","title":"CircoCore.isbaseaddress","text":"isbaseaddress(addr::Addr)::Bool\n\nReturn true if addr is a base address, meaning it references a scheduler directly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.isnulladdr-Tuple{Addr}","page":"Reference","title":"CircoCore.isnulladdr","text":"isnulladdr(a::Addr)\n\nCheck if the given address is a null address, meaning that it points to \"nowhere\", messages sent to it will be dropped.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.onmessage-Tuple{Actor, Any, Any}","page":"Reference","title":"CircoCore.onmessage","text":"onmessage(me::Actor, message, service)\n\nHook to handle a message arriving at an actor.\n\nOnly the payload of the message is delivered, there is currently no way to access the infoton or the sender address. If you need a reply, include the sender address in the request.\n\nNote: Do not forget to import it or use its qualified name to allow overloading!\n\nExamples\n\nimport CircoCore.onmessage\n\nstruct TestRequest\n    replyto::Addr\nend\n\nstruct TestResponse end\n\nfunction onmessage(me::MyActor, message::TestRequest, service)\n    send(service, me, message.replyto, TestResponse())\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.onspawn-Tuple{Actor, Any}","page":"Reference","title":"CircoCore.onspawn","text":"CircoCore.onspawn(me::Actor, service)\n\nLifecycle callback that marks the first scheduling of the actor, called during spawning, before any onmessage.\n\nNote: Do not forget to import it or use its qualified name to allow overloading!\n\nExamples\n\nimport CircoCore.onspawn\n\nfuntion onspawn(me::MyActor, service)\n    registername(service, \"MyActor\", me) # Register this actor in the local name service\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.pos-Tuple{Actor}","page":"Reference","title":"CircoCore.pos","text":"pos(a::Actor)::Pos\n\nreturn the current position of the actor.\n\nCall this on a spawned actor to get its position. Throws UndefRefError if the actor is not spawned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.redirect-Tuple{Addr, String}","page":"Reference","title":"CircoCore.redirect","text":"redirect(addr::Addr, topostcode::PostCode):Addr\n\nCreate a new Addr by replacing the postcode of the given one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.registername-Tuple{Any, String, Actor}","page":"Reference","title":"CircoCore.registername","text":"registername(service, name::String, actor::Actor)\n\nRegister the given actor under the given name in the scheduler-local name registry.\n\nNote that there is no need to unregister the name when migrating or dying\n\nTODO implement manual and auto-unregistration\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.spawn-Tuple{Circo Service, Actor}","page":"Reference","title":"CircoCore.spawn","text":"spawn(service, actor::Actor, [pos::Pos])::Addr\n\nSpawn the given actor on the scheduler represented by service, return the address of it.\n\nPart of the actor API, can be called from a lifecycle callback, providing the service you got.\n\nThe onspawn callback of actor will run before this function returns.\n\nExamples\n\nTODO: update this sample\n\nmutable struct ListItem{TData, TCore} <: Actor{TCore}\n    data::TData\n    next::Union{Nothing, Addr}\n    core::TCore\n    ListItem(data, core) = new{typeof(data), typeof(core)}(data, nothing, core)\nend\n\nstruct Append{TData}\n    value::TData\nend\n\nfunction CircoCore.onmessage(me::ListItem, message::Append, service)\n    me.next = spawn(service, ListItem(message.value))\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Circo]","category":"page"},{"location":"reference/#Circo.onmigrate-Tuple{Actor, Any}","page":"Reference","title":"Circo.onmigrate","text":"onmigrate(me::Actor, service)\n\nLifecycle callback that marks a successful migration.\n\nIt is called on the target scheduler, before any messages will be delivered.\n\nNote: Do not forget to import it or use its qualified name to allow overloading!\n\nExamples\n\nfunction Circo.onmigrate(me::MyActor, service)\n    @info \"Successfully migrated, registering a name on the new scheduler\"\n    registername(service, \"MyActor\", me)\nend\n\n\n\n\n\n","category":"method"},{"location":"infotons/#Infoton-Optimization","page":"Infoton Optimization","title":"Infoton Optimization","text":"","category":"section"},{"location":"infotons/#Introduction","page":"Infoton Optimization","title":"Introduction","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"An old issue of distributed systems comes from the layered cost&latency structure of communication: Networks are slow and bandwidth-limited, whereas inter-thread communication is much faster, but still slow compared to in-thread data passing. Thus communication is often the performance bottleneck that limits scalability and needs to be optimized.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"Infoton optimization is a physics-inspired model to minimize communication in message-passing distributed systems. It is essentially a decentralized, scalable version of force-directed graph drawing, aka \"spring layout\" [1].","category":"page"},{"location":"infotons/#Description","page":"Infoton Optimization","title":"Description","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"Infoton optimization is executed in a \"3D Euclidean\" space, where actors[2] and schedulers (threads that execute actor code) are embedded. The central idea is that actors move close to their communication partners in the space, while distance between them approximates communication costs. This way the communication cost is minimized.","category":"page"},{"location":"infotons/#To-move-communicating-actors-close-to-each-other:","page":"Infoton Optimization","title":"To move communicating actors close to each other:","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"B1. A so-called infoton, a force-carrying particle is attached to every message passed between actors. It is a small structure that holds the position of the source actor and a scalar \"energy\".","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"B2. When the message arrives at its destination actor, the infoton that is attached to it acts on that actor, pulling it towards the source of the message.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"This is the base of infoton optimization. Now, this alone would result in all the actors concentrating around a single point, so we need at least one another force to spread the actors in the segment of the space which is \"covered\" with schedulers. For this:","category":"page"},{"location":"infotons/#To-approximate-communication-overhead-with-actor-distance:","page":"Infoton Optimization","title":"To approximate communication overhead with actor distance:","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"E1. Schedulers are also embedded in the space, in a way that their distance represents communication overhead between them. This can be done either by static positioning or the use of network coordinates.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"E2. Actors are migrated to the nearest scheduler.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"E3. When a message arrives, the scheduler that executes the target actor creates a second infoton. The source of this \"scheduler infoton\" is the scheduler itself.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"E4. This infoton either pulls or pushes the actor toward or away from the scheduler, depending on the \"load\" of the scheduler. The pulling/pushing behavior of the infoton is called its sign, and it is implemented as the sign of its energy field.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"Mapping the state of the system - as avaiable on individual schedulers - to the signed energy of scheduler infotons is an active research area with some promising results already. Other extensions of the base are also possible.","category":"page"},{"location":"infotons/#Sample-images","page":"Infoton Optimization","title":"Sample images","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"(Image: ) I1: A balanced binary tree of actors spreads out to fill part of the space that is covered by 6 schedulers. Green and red dots are leafs, red meaning the leaf is 90% full or more. Purple dots are inner nodes of the search tree.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"(Image: ) I2: A different rendering of a scene similar to I1. Orange lines cross scheduler boundary, gray lines don't.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"(Image: ) I3: A linked list of 4000 actors spreads out to fill part of the space that is covered by 6 schedulers.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"(Image: ) I4: A better solution of I3, rendered sightly differently.","category":"page"},{"location":"infotons/#Notes","page":"Infoton Optimization","title":"Notes","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"N1. The limits and applicability of this algorithm is not yet explored, implementation details are not fixed. Quoted terms in the description mark areas of uncertainty.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"N2. The cost of this optimization is a small, constant overhead on every message sent, plus the overhead of actor migration.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"N3. Actors cannot collide in the base model and in the extended one currently implemented in Circo. Multiple actors may be positioned at the exact same place.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"N4. However, domain-specific knowledge or special requirements can be added by sending negative signal messages. E.g. If multiple copies of a piece of data exist in the system for failure tolerance, the copies can preiodically check the liveness of each other while also spread as a result.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"N5. A similar domain mechanism works in the tree example, where neighbour nodes \"periodically\" ping each other with negative infotons.","category":"page"},{"location":"infotons/#Sample-code","page":"Infoton Optimization","title":"Sample code","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"This is the current default implementation in Circo of how an infoton acts on the target actor. In this version pulling forces are not applied if the distance between the source and the target is too small. This trick seems to lead to better results in some cases. It introduces a metaparameter called TARGET_DISTANCE, and it can be thought of as a rudimentary approximation of a separate force that pushes actors away when they are too close.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"Pos = VecE3{Float32} # 3D coordinates\n\nstruct Infoton\n    sourcepos::Pos\n    energy::Float32 # The sign of this field is called the sign of the Infoton\n    Infoton(sourcepos::Pos, energy::Real = 1) = new(sourcepos, Float32(energy))\nend\n\nconst TARGET_DISTANCE = 15.0\n\nfunction apply_infoton(space::Space, targetactor::Actor, infoton::Infoton)\n    diff = infoton.sourcepos - targetactor.core.pos\n    difflen = norm(diff)\n    energy = infoton.energy\n    if energy > 0 && difflen < TARGET_DISTANCE\n        return nothing\n    end\n    targetactor.core.pos += diff / difflen * energy\n    return nothing\nend","category":"page"},{"location":"infotons/#How-to-start-research-on-Infoton-optimization","page":"Infoton Optimization","title":"How to start research on Infoton optimization","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"You can overload apply_infoton and scheduler_infoton for your actor (and/or plugin) types. Actor positioning is implemented as a plugin. All you need to do is to install the system and run the examples where you can tweak the current rudimentary implementation. Please share your findings on Discourse!","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"[2]: For simplicity, here I use the actor model to describe the algorithm, but it can be adapted to other concurrency models.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"[1]: Force-directed graph drawing in Wikipedia","category":"page"},{"location":"#Introducing-Circo","page":"Introducing Circo","title":"Introducing Circo","text":"","category":"section"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Circo is a fast, scalable and extensible actor system.","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Fast: Up to 630 million msg/sec on a single node [singlenode]. Up to 20 million msg/sec single threaded performance.\nScalable: Includes a decentralized cluster manager to avoid single point of failure.\nExtensible: Built on top of a custom-made plugin system which allows inlining of plugin code into the main event loop. Multithreading is a plugin. Actor migration is a plugin. Even last-mile message delivery is a plugin. If something is not a plugin, that's a bug.","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Circo also features Infoton Optimization, a physics-inspired solution to the data-locality problem. [infoton]","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Circo is implemented in Julia - an incredibly fast, dynamic, yet compiled language -, and it has a JavaScript sister: Circo.js, which can run in the browser and transparently integrate into the Circo cluster. These two components form a high performance, distributed application platform.","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"There is a monitoring tool named \"Camera Diserta\" which can help to tune Circo applications and to research Infoton Optimization.","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Please note that Circo is in alpha stage. It is more like a research tool at the time than a mature platform. The documentation is also far from complete. Contributions are welcome!","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"[singlenode]: Measured on an AWS C6g 16xlarge instance, 64 Graviton2 Arm core. See maxthroughput.jl","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"[infoton]: Go to Infoton Optimization for a description of this novel algorithm.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/Circo-dev/Circo/blob/master/docs/src/tutorial.jl\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<style>\n  .documenter-example-output { display:none !important }\n  .is-category-output { background-color: white  !important; color: black !important; border-color: lightsteelblue !important}\n  .is-category-output pre, .is-category-output code { background-color: white  !important; color: black !important; border-width: 0 !important}\n  .is-category-output .admonition-header { background-color: lightsteelblue !important }\n</style>","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here you will learn how to start Circo, create actors, send messages and react to lifecycle events. We will program a distributed backend for Twitter clones from scratch.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Don't worry, it is not complicated, just a simplified prototype! But it works, and it scales to any size...","category":"page"},{"location":"tutorial/#Architecture","page":"Tutorial","title":"Architecture","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We build the system out of three building blocks: Posts, Feeds and Profiles.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Posts are simple structs with some text and the name of the author.\nFeeds are actors holding a list of posts. When someone opens the frontend,  a new feed will be created for that session, and populated with recent posts.  While the feed is alive, it also receives pushed updates from its sources.\nProfile actors can create posts and follow other profiles.","category":"page"},{"location":"tutorial/#Post","page":"Tutorial","title":"Post","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We start with Post, which is a simple struct, as it has no behavior currently. We will store posts in feeds and profiles, and pass them as messages.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Circo\n\nstruct Post\n    authorname::String\n    text::String\nend","category":"page"},{"location":"tutorial/#Feed","page":"Tutorial","title":"Feed","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A Feed - our first - actor contains a growing list of posts from different authors.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Actors in Circo are mutable structs[encapsulation], subtypes of Actor:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"[encapsulation]: Actors encapsulate their state: They are to be accessed only through message passing. This strict separation enables the scalability of the actor model, and I also believe that it is very natural, meaning that it is aligned with how nature works. It seems that shared state is not common in nature, which explains why systems that provide shared state scale poorly.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mutable struct Feed <: Actor{Any}\n    sources::Vector{Addr} # Post sources that this feed watches\n    posts::Vector{Post}\n    core::Any # A tiny boilerplate is needed\n    Feed(sources) = new(sources, [])\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"core is a required field to store system info, e.g. the id of the actor. You may sometimes use the information in core, but you should never access it directly, as its content is not fixed: Its type is assembled by the activated plugins.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When the feed receives a Post, it just prints and stores it:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function Circo.onmessage(me::Feed, post::Post, service)\n    println(\"Feed $(box(me)) received post: $post\")\n    push!(me.posts, post)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By adding a method to Circo.onmessage we have defined how Feed actors react, when they receive a Post as a message.[behaviors] The here unused service argument is for sending out messages, spawning actors or communicating with plugins.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"[behaviors]: Unlike other actor systems, Circo does not complicate things with replaceable actor behaviors. When we need an actor to change its behavior dynamically, we can dispatch further in onmessage, or spawn another actor. As always, performance was the main driver behind this design decision, but the API is also definitely simpler. Actors are like objects in OOP, and objects does not have replaceable behaviors.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/#Try-out-what-we-have","page":"Tutorial","title":"Try out what we have","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"feed = Feed([])\n\nctx = CircoContext()\ns = Scheduler(ctx, [feed])\nrun!(s) # Start the scheduler in the background","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The CircoContext manages the configuration and helps building a tailored system: it loads the plugins, generates types, etc. The Scheduler then executes our actors in that context.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The feed is scheduled and waiting for posts. We can send one from the outside:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"send(s, feed, Post(\"Me\", \"My first post\"))\nsleep(1.0) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"output: Output\nFeed 15794352489972218257 received post: Main.Post(\"Me\", \"My first post\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Great, the post arrived at the feed and got processed!","category":"page"},{"location":"tutorial/#Profile","page":"Tutorial","title":"Profile","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we will create a Profile actor that can create posts and follow other profiles.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mutable struct Profile <: Actor{Any}\n    name::String\n    posts::Vector{Post}\n    following::Vector{Addr} # Adresses of the profiles we follow\n    watchers::Vector{Addr} # Feeds to notify about our new posts\n    core::Any\n    Profile(name) = new(name, [], [], [])\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Profile will start following another one if it receives the Follow message:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct Follow\n    whom::Addr\nend\n\nfunction Circo.onmessage(me::Profile, msg::Follow, service)\n    println(\"$(me.name) ($(box(me))): Starting to follow $(box(msg.whom))\")\n    push!(me.following, msg.whom)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can create a few profiles and connect them. But first the running scheduler has to be paused and restarted for the new onmessage method to take effect.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pause!(s); run!(s)\nalice = spawn(s, Profile(\"Alice\"))\nbela = spawn(s, Profile(\"Béla\"))\ncecile = spawn(s, Profile(\"Cécile\"))\n\nsend(s, alice, Follow(bela))\nsend(s, alice, Follow(cecile))\nsend(s, bela, Follow(cecile))\nsleep(1.0) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"output: Output\nAlice (2519498415121108185): Starting to follow 3749599043616972853\nAlice (2519498415121108185): Starting to follow 5769659525869689442\nBela (3749599043616972853): Starting to follow 5769659525869689442","category":"page"},{"location":"tutorial/#Creating-Posts,-notifying-watchers","page":"Tutorial","title":"Creating Posts, notifying watchers","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Profiles will create posts when they receive a CreatePost message:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct CreatePost\n    text::String\nend\n\nfunction Circo.onmessage(me::Profile, msg::CreatePost, service)\n    post = Post(me.name, msg.text)\n    println(\"Posting: $post\")\n    push!(me.posts, post)\n    notify_watchers(me, post, service) # Send out the post to the feeds of our live followers (if any)\nend\n\nfunction notify_watchers(me::Profile, post, service)\n    for watcher in me.watchers\n        send(service, me, watcher, post)\n    end\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let our users create a few interesting posts:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pause!(s); run!(s)\nsend(s, alice, CreatePost(\"Through the Looking-Glass\"))\nsend(s, bela, CreatePost(\"I lost my handkerchief\"))\nsend(s, cecile, CreatePost(\"My first post\"))\nsend(s, cecile, CreatePost(\"At the zoo\"))\nsleep(1.0) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"output: Output\nPosting: Main.Post(\"Alice\", \"Through the Looking-Glass\")\nPosting: Main.Post(\"Bela\", \"I lost my handkerchief\")\nPosting: Main.Post(\"Cécile\", \"My first post\")\nPosting: Main.Post(\"Cécile\", \"At the zoo\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As there isn't any feed watching the profiles at the time, no notifications were sent out.","category":"page"},{"location":"tutorial/#Creating-feeds","page":"Tutorial","title":"Creating feeds","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"So, time to create a live feed! The CreateFeed message asks a profile to create a feed that is sourced from the profiles that this one follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct CreateFeed end\nfunction Circo.onmessage(me::Profile, msg::CreateFeed, service)\n    feed = spawn(service, Feed(copy(me.following)))\n    println(\"Created Feed: $(feed)\")\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When the feed actor is spawned, it starts watching the profiles by sending them an AddWatcher message:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct AddWatcher\n    watcher::Addr\nend\n\nfunction Circo.onspawn(me::Feed, service)\n    for source in me.sources\n        send(service, me, source, AddWatcher(addr(me)))\n    end\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The profile reacts with immediately sending back its last 3 posts, and starting to send notifications about future posts:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function Circo.onmessage(me::Profile, msg::AddWatcher, service)\n    for post in me.posts[max(end - 2, 1):end]\n        send(service, me, msg.watcher, post)\n    end\n    push!(me.watchers, msg.watcher)\nend","category":"page"},{"location":"tutorial/#Ta-da","page":"Tutorial","title":"Ta-da","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We are ready! We do not want to create the frontend, so let's just say that when someone opens the frontend app on their device, a Circo plugin or an external system will call:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pause!(s); run!(s) # hide\nsend(s, alice, CreateFeed())\nsleep(1.0) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"output: Output\nCreated Feed: 192.168.193.99:24721/898192691fd68c14\nFeed 9908361635395177492 received post: Main.Post(\"Cécile\", \"My first post\")\nFeed 9908361635395177492 received post: Main.Post(\"Cécile\", \"At the zoo\")\nFeed 9908361635395177492 received post: Main.Post(\"Béla\", \"I lost my handkerchief\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That's it! Just a final check that when Béla creates a new post, it will arrive on the feed of Alice:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"send(s, bela, CreatePost(\"Have you ever seen a llama wearing pajamas?\"))\nsleep(1.0) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"output: Output\nPosting: Main.Post(\"Bela\", \"Have you ever seen a llama wearing pajamas?\")\nFeed 9908361635395177492 received post: Main.Post(\"Bela\", \"Have you ever seen a llama wearing pajamas?\")","category":"page"},{"location":"tutorial/#Where-to-go","page":"Tutorial","title":"Where to go","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Nothing more is needed to start coding in Circo. The best way to learn is to make something yourself.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For closer-to-life Circo programs look into the examples folder of the repo.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Have fun!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
